#!/bin/bash
{
	#////////////////////////////////////
	# DietPi-Globals
	#
	#////////////////////////////////////
	# Created by Daniel Knight / daniel.knight@dietpi.com / dietpi.com
	#
	#////////////////////////////////////
	#
	# Info:
	# - Provides shared/global DietPi variables and functions for current bash session and DietPi scripts
	# - CRITICAL, use local index variables in for/while loops, or unset them afterwards, else havoc: https://github.com/MichaIng/DietPi/issues/1454
	# - Sourced/Loaded in interactive bash sessions: /etc/bashrc.d/dietpi.bash
	# - Sourced/Loaded as start of most DietPi script
	#////////////////////////////////////

	#-----------------------------------------------------------------------------------
	# Core variables, functions and environment, used at start of all scripts
	#-----------------------------------------------------------------------------------
	# To be set by the originating script, after loading globals and before calling G_INIT()
	# - Used in G_ERROR_HANDLER, G_WHIP_* and G_DIETPI-NOTIFY functions
	unset G_PROGRAM_NAME

	# Debug mode
	# - Do no pre-generate to reduce bash session variables => Needs to be checked via: [[ $G_DEBUG == 1 ]]
	#G_DEBUG=${G_DEBUG:-0}

	# Interactive mode
	# - Affects whether G_ERROR_ and G_WHIP_ prompts are displayed or not
	# - Run "export G_INTERACTIVE=0" prior to script call to force non-interactive/automated mode.
	# - Run "unset G_INTERACTIVE" afterwards to return to auto detection.
	# - If not set, check for STDIN availability:
	#	OK | systemd	= no STDIN
	#	OK | Cron	= no STDIN
	#	NB | /etc/profile, ~/.profile, /etc/profile.d/, /etc/bash.bashrc, ~/.bashrc and /etc/bashrc.d/ are interactive since those are sourced from originating shell/bash session.
	if [[ $G_INTERACTIVE != [01] ]]; then

		# Backwards compatibility to keep user scripts valid for a while
		if [[ $G_USER_INPUTS == [01] ]]; then

			G_INTERACTIVE=$G_USER_INPUTS

		else

			[[ -t 0 ]] && G_INTERACTIVE=1 || G_INTERACTIVE=0

		fi

	fi

	# DietPi First-Run Stage | -2 = PREP_SYSTEM/Unknown | -1 = 1st boot | 0 = 1st run dietpi-update | 1 = 1st run dietpi-software | 2 = completed | 10 = Pre-installed image, converts to 2 during 1st boot
	[[ -f '/DietPi/dietpi/.install_stage' ]] && G_DIETPI_INSTALL_STAGE=$(</DietPi/dietpi/.install_stage) || G_DIETPI_INSTALL_STAGE=-2

	# DietPi version and Git branch
	G_DIETPI_VERSION_CORE=${G_DIETPI_VERSION_CORE:-6}
	G_DIETPI_VERSION_SUB=${G_DIETPI_VERSION_SUB:-26}
	G_DIETPI_VERSION_RC=${G_DIETPI_VERSION_RC:-3}
	G_GITBRANCH=${G_GITBRANCH:-master}
	G_GITOWNER=${G_GITOWNER:-MichaIng}
	[[ -f '/DietPi/dietpi/.version' && $(</DietPi/dietpi/.version) == '#!/bin/bash'* ]] && . /DietPi/dietpi/.version

	G_VERSIONDB_SAVE(){

		cat << _EOF_ > /DietPi/dietpi/.version
#!/bin/bash
G_DIETPI_VERSION_CORE=$G_DIETPI_VERSION_CORE
G_DIETPI_VERSION_SUB=$G_DIETPI_VERSION_SUB
G_DIETPI_VERSION_RC=$G_DIETPI_VERSION_RC
G_GITBRANCH='$G_GITBRANCH'
G_GITOWNER='$G_GITOWNER'
_EOF_

	}

	# Default DietPi userdata location, which must NEVER change!
	# - NB: In case of moved userdata location, a symlink stays here to keep this path valid.
	G_FP_DIETPI_USERDATA='/mnt/dietpi_userdata'

	# Allows to disable dietpi-services handling, e.g. if already handled within parent script.
	# - Do no pre-generate to reduce bash session variables => Needs to be checked via: [[ $G_DIETPI_SERVICES_DISABLE == 1 ]]
	#G_DIETPI_SERVICES_DISABLE=${G_DIETPI_SERVICES_DISABLE:-0}

	# Device details
	# - Declare
	G_HW_MODEL=${G_HW_MODEL:--1}
	G_HW_MODEL_DESCRIPTION=${G_HW_MODEL_DESCRIPTION:-NULL}
	G_HW_ARCH=${G_HW_ARCH:-0}
	G_HW_ARCH_DESCRIPTION=$(uname -m)
	G_HW_CPUID=${G_HW_CPUID:-0}
	G_HW_CPU_CORES=$(nproc --all)

	G_DISTRO=${G_DISTRO:-0}
	G_DISTRO_NAME=${G_DISTRO_NAME:-NULL}

	# - Update
	#	NB: dietpi-preboot.service launches dietpi-obtain_hw_model to create the following file
	if [[ -f '/DietPi/dietpi/.hw_model' ]]; then

		G_HW_MODEL=$(mawk 'NR==1 {print}' /DietPi/dietpi/.hw_model)
		G_HW_MODEL_DESCRIPTION=$(mawk 'NR==2 {print}' /DietPi/dietpi/.hw_model)
		G_HW_ARCH=$(mawk 'NR==6 {print}' /DietPi/dietpi/.hw_model)
		G_HW_CPUID=$(mawk 'NR==9 {print}' /DietPi/dietpi/.hw_model)

		G_DISTRO=$(mawk 'NR==3 {print}' /DietPi/dietpi/.hw_model)
		if (( $G_DISTRO == 4 )); then

			G_DISTRO_NAME='stretch'

		elif (( $G_DISTRO == 5 )); then

			G_DISTRO_NAME='buster'

		elif (( $G_DISTRO == 6 )); then

			G_DISTRO_NAME='bullseye'

		fi

	fi

	# Init functions for originating script
	# - Stuff we can't init in main globals/funcs due to /etc/bashrc.d/ load into login session.
	# - Optional input variables:
	#	G_INIT_ALLOW_CONCURRENT=1	= Allow concurrent DietPi script execution (default: 0)
	#	G_INIT_WAIT_CONCURRENT=<int>	= Max time to wait for concurrent execution to exit before user prompt (default: 5)
	G_INIT(){

		# Set G_PROGRAM_NAME to originating command if it was not set by originating script
		[[ $G_PROGRAM_NAME ]] || G_PROGRAM_NAME=$0

		[[ $G_DEBUG == 1 ]] && G_DIETPI-NOTIFY 3 "$G_PROGRAM_NAME" 'Running G_INIT()'

		# Check for concurrent execution
		if [[ $G_INIT_ALLOW_CONCURRENT != 1 ]]; then

			local timer=0
			local limit=${G_INIT_WAIT_CONCURRENT:-5}

			while [[ -d /tmp/$G_PROGRAM_NAME ]]
			do

				if (( $timer < $limit )); then

					G_DIETPI-NOTIFY 2 "Concurrent execution of $G_PROGRAM_NAME detected: Retry ($timer/$limit), please wait..."

					sleep 1
					((timer++))

				else

					G_WHIP_BUTTON_OK_TEXT='Retry'
					if ! G_WHIP_YESNO "WARNING: Concurrent execution of $G_PROGRAM_NAME detected\n
Please check if one of the following applies:
 - This script already runs on another terminal/SSH session.
 - Currently a cron or systemd background job executes the script.
 - You started this script from within another DietPi program, causing a loop.\n
Please assure that the concurrent execution has finished, before retrying, otherwise cancel this instance.\n
The following info might help:
$(ps f -eo pid,user,tty,cmd | grep -i '[d]ietpi')"; then

						G_DIETPI-NOTIFY 1 "Cancelled $G_PROGRAM_NAME due to concurrent execution"
						exit 1

					fi

				fi

			done

		fi

		# HIERARCHY system for G_DIETPI-NOTIFY 3 to reduce highlight or sub script output
		disable_error=1 G_CHECK_VALIDINT "$HIERARCHY" 0 && export HIERARCHY=$((HIERARCHY+1)) || export HIERARCHY=0

		# Set locale for scripts to prevent incorrect scraping due to translated command outputs
		export LC_ALL='en_GB.UTF-8'

		# Declare exit trap, that runs on EXIT signal, which includes INT (interruption) and TERM (kill)
		G_EXIT(){

			# - Navigate to /tmp, if we are inside working dir, which is about to be removed
			if cd /tmp; then

				[[ $G_DEBUG == 1 ]] && G_DIETPI-NOTIFY 2 'Navigated to /tmp'

			else

				[[ $G_DEBUG == 1 ]] && G_DIETPI-NOTIFY 2 'Failed to navigate to /tmp'

			fi

			# - Purge working directory, if existent and no concurrency allowed
			if [[ $G_INIT_ALLOW_CONCURRENT != 1 && -d /tmp/$G_PROGRAM_NAME ]]; then

				if rm -R /tmp/$G_PROGRAM_NAME; then

					[[ $G_DEBUG == 1 ]] && G_DIETPI-NOTIFY 2 "Removed scripts working directory: /tmp/$G_PROGRAM_NAME"

				else

					[[ $G_DEBUG == 1 ]] && G_DIETPI-NOTIFY 2 "Failed to remove scripts working directory: /tmp/$G_PROGRAM_NAME"

				fi

			fi

			# - Execute custom exit function, if existent
			declare -F G_EXIT_CUSTOM &> /dev/null && G_EXIT_CUSTOM

		}
		trap 'G_EXIT' EXIT

		# Ensure we are in script working dir or users home dir, if available: https://github.com/MichaIng/DietPi/issues/905#issuecomment-298223705
		if [[ $G_PROGRAM_NAME ]] && mkdir -p /tmp/$G_PROGRAM_NAME && cd /tmp/$G_PROGRAM_NAME; then

			[[ $G_DEBUG == 1 ]] && G_DIETPI-NOTIFY 2 "Entered scripts working directory: /tmp/$G_PROGRAM_NAME"

		elif [[ -d $HOME ]] && cd $HOME; then

			[[ $G_DEBUG == 1 ]] && G_DIETPI-NOTIFY 2 "Entered users home directory: $HOME"

		else

			[[ $G_DEBUG == 1 ]] && G_DIETPI-NOTIFY 2 "Failed to enter scripts working dir or users home dir. Will use current: $PWD"

		fi

	}

	# DietPi-Notify
	# $1:
	#	-2=process animation
	#	- $2 = text
	#	-1=autodetect_fail_ok
	#	- $2 = EXIT_CODE
	#	0=OK
	#	- $2 = text
	#	1=failed
	#	- $2 = text
	#	2=info
	#	- $2 = text
	#	3=DietPi banner style
	#	- $2 = txt program name
	#	- $3 = txt mode
	G_DIETPI-NOTIFY(){

		local ainput_string=("$@")
		local output_string=''
		local bracket_l='\e[0m\e[90m[\e[0m'
		local bracket_r='\e[0m\e[90m]\e[0m'

		# Funcs
		Clean_Process_Animation(){

			if [[ -t 0 && -w '/tmp/dietpi-process.pid' ]]; then

				kill -9 $(</tmp/dietpi-process.pid) &> /dev/null
				rm /tmp/dietpi-process.pid &> /dev/null

			fi
			# To cover multiline output, clean from cursor (animation position) until end of screen.
			output_string='\r\e[J'

		}

		Status_Ok(){

			Clean_Process_Animation
			output_string+="$bracket_l\e[32m  OK  $bracket_r "

		}

		Status_Failed(){

			Clean_Process_Animation
			output_string+="$bracket_l\e[31mFAILED$bracket_r "

		}

		# Print all input string on same line
		# - $1 = start printing from word number $1
		Print_Output_String(){

			[[ $1 == 1 && $G_PROGRAM_NAME ]] && output_string+="\e[90m$G_PROGRAM_NAME | \e[0m"
			local i=0
			for ((i=$1; i<${#ainput_string[@]}; i++))
			do

				output_string+=${ainput_string[$i]}

			done
			echo -ne "$output_string\e[0m"

		}

		#--------------------------------------------------------------------------------------
		# Main Loop
		#--------------------------------------------------------------------------------------
		# Exit code, print OK or Failed
		# $2 = exit code
		# - Use this at end of DietPi scripts, EG: G_DIETPI-NOTIFY -1 ${EXIT_CODE:=0}
		if (( $1 == -1 )); then

			if (( ! $2 )); then

				Status_Ok
				ainput_string+=(' Completed\n')
				Print_Output_String 2

			else

				Status_Failed
				ainput_string+=(' An issue has occurred\n')
				Print_Output_String 2

			fi

		#--------------------------------------------------------------------------------------
		# Status Processing
		# $@ = txt desc
		elif (( $1 == -2 )); then

			output_string="\r$bracket_l\e[33m .... $bracket_r "
			Print_Output_String 1

			if [[ -t 0 ]]; then

				Print_Process_Animation(){

					local bright_dot='\e[1;33m.'
					local dimmed_dot='\e[0;33m.'
					# Alternative: \u23F9
					local aprocess_string=(
						"$bright_dot     "
						"$dimmed_dot$bright_dot    "
						" $dimmed_dot$bright_dot   "
						"  $dimmed_dot$bright_dot  "
						"   $dimmed_dot$bright_dot "
						"    $dimmed_dot$bright_dot"
						"     $bright_dot"
						"    $bright_dot$dimmed_dot"
						"   $bright_dot$dimmed_dot "
						"  $bright_dot$dimmed_dot  "
						" $bright_dot$dimmed_dot   "
						"$bright_dot$dimmed_dot    "
					)

					local i=0
					for (( i=0; i<=${#aprocess_string[@]}; i++ )); do

						(( i == ${#aprocess_string[@]} )) && i=0
						[[ -w '/tmp/dietpi-process.pid' ]] && echo -ne "\r$bracket_l${aprocess_string[$i]}$bracket_r " || return
						sleep 0.15

					done

				}

				# Calculate the amount of output lines and in case move cursor up for correct animation and to allow cleaning the whole output.
				local input_string=$(mawk '{gsub("\\\e[[0-9][;0-9]*m","");print}' <<< "${G_PROGRAM_NAME+$G_PROGRAM_NAME | }$*") # Remove colour codes
				local screen_width=${G_WHIP_SIZE_X_OVERRIDE:-$(tput cols)} # Use override value in case STDOUT + STDERR are redirected
				local output_lines=$(( ( ${#input_string} + 5 ) / $screen_width )) # +5 = [ .... ] - $1
				(( $output_lines )) && echo -ne "\e[${output_lines}A"
				# If redirect to existent PID file fails due to noclobber, don't start processing animation.
				# - This method prevents a tiny condition race from checking file existance until creating it, when doing: [[ ! -e file ]] && > file
				set -C
				if { > /tmp/dietpi-process.pid; } &> /dev/null; then

					set +C
					{ Print_Process_Animation & echo $! > /tmp/dietpi-process.pid; disown; } 2> /dev/null

				else

					set +C

				fi

				unset Print_Process_Animation

			fi

		# Status Ok
		# $@ = txt desc
		elif (( $1 == 0 )); then

			Status_Ok
			ainput_string+=('\n')
			Print_Output_String 1

		# Status failed
		# $@ = txt desc
		elif (( $1 == 1 )); then

			Status_Failed
			ainput_string+=('\n')
			Print_Output_String 1

		# Status Info
		# $@ = txt desc
		elif (( $1 == 2 )); then

			Clean_Process_Animation
			output_string+="$bracket_l INFO $bracket_r "
			# Keep info messages in gray, even if "$G_PROGRAM_NAME | \e[0m" is added:
			ainput_string[1]="\e[90m${ainput_string[1]}"
			ainput_string+=('\n')
			Print_Output_String 1

		# DietPi banner style
		# $2 = txt program name
		# $3 = txt mode
		elif (( $1 == 3 )); then

			Clean_Process_Animation
			if disable_error=1 G_CHECK_VALIDINT "$HIERARCHY" 1; then

				local status_subfunction="$HIERARCHY "
				# > 9 should never occur, however, if it is, lets make it line up regardless
				(( $HIERARCHY > 9 )) && status_subfunction=$HIERARCHY

				output_string+="$bracket_l\e[33m SUB$status_subfunction$bracket_r $2 > "
				ainput_string+=('\n')

			else

				output_string+="
 \e[38;5;154m$2\e[0m
\e[90m─────────────────────────────────────────────────────
 Mode: \e[0m"
				ainput_string+=('\n\n')

			fi

			Print_Output_String 2

		fi
		#-----------------------------------------------------------------------------------
		# Unset internal functions, otherwise they are accessible from terminal
		unset Clean_Process_Animation Status_Ok Status_Failed Print_Output_String
		#-----------------------------------------------------------------------------------

	}

	# $1 = mode
	#	2	= Silent check, only returning error code if non-root
	#	1	= Kill current script only, excluding the shell.
	#	else	= Exit all linked scripts (kill all)
	G_CHECK_ROOT_USER(){

		if (( $UID )); then

			[[ $1 == 2 ]] && return 1

			G_DIETPI-NOTIFY 1 'Root privileges required. Please run the command with "sudo" or "G_SUDO".'

			if [[ $1 == 1 ]]; then

				kill -INT $$

			else

				exit 1

			fi

		fi

	}

	G_CHECK_ROOTFS_RW(){

		if [[ $G_CHECK_ROOTFS_RW_VERIFIED != 1 ]]; then

			if grep -q '[[:blank:]]/[[:blank:]].*[[:blank:]]ro,' /proc/mounts; then

				G_DIETPI-NOTIFY 1 'RootFS is currently Read Only (R/O) mounted. Aborting...'
				G_DIETPI-NOTIFY 2 'DietPi requires RootFS to be Read/Write (R/W) mounted. Please run "dietpi-drive_manager" to re-enable.\n'
				exit 1

			else

				export G_CHECK_ROOTFS_RW_VERIFIED=1

			fi

		fi

	}

	#-----------------------------------------------------------------------------------
	# Alias defines
	#-----------------------------------------------------------------------------------
	# DietPi scripts, moved from /etc/bash.bashrc
	# - sudo wrapper that ensures DietPi-Globals with G_* commands are loaded
	G_SUDO(){ local input=$@; sudo bash -c ". /DietPi/dietpi/func/dietpi-globals && $input"; }
	# - sudo alias that allows running other aliases with "sudo": https://github.com/MichaIng/DietPi/issues/424
	alias sudo='sudo '

	# - DietPi programs
	alias dietpi-process_tool='/DietPi/dietpi/dietpi-services' # Leave this in for few versions for end users, due to switchover to dietpi-services
	alias dietpi-letsencrypt='/DietPi/dietpi/dietpi-letsencrypt'
	alias dietpi-autostart='/DietPi/dietpi/dietpi-autostart'
	alias dietpi-cron='/DietPi/dietpi/dietpi-cron'
	alias dietpi-launcher='/DietPi/dietpi/dietpi-launcher'
	alias dietpi-cleaner='/DietPi/dietpi/dietpi-cleaner'
	alias dietpi-morsecode='/DietPi/dietpi/dietpi-morsecode'
	alias dietpi-sync='/DietPi/dietpi/dietpi-sync'
	alias dietpi-backup='/DietPi/dietpi/dietpi-backup'
	alias dietpi-bugreport='/DietPi/dietpi/dietpi-bugreport'
	alias dietpi-services='/DietPi/dietpi/dietpi-services'
	alias dietpi-config='/DietPi/dietpi/dietpi-config'
	alias dietpi-software='/DietPi/dietpi/dietpi-software'
	alias dietpi-update='/DietPi/dietpi/dietpi-update'
	alias dietpi-drive_manager='/DietPi/dietpi/dietpi-drive_manager'
	alias dietpi-logclear='/DietPi/dietpi/func/dietpi-logclear'
	alias dietpi-survey='/DietPi/dietpi/dietpi-survey'
	alias dietpi-explorer='/DietPi/dietpi/dietpi-explorer'
	alias dietpi-banner='/DietPi/dietpi/func/dietpi-banner 2'
	alias dietpi-justboom='/DietPi/dietpi/misc/dietpi-justboom'

	alias cpu='/DietPi/dietpi/dietpi-cpuinfo'

	# - 1337 moments ;)
	alias 1337='echo Indeed, you are =\)'

	# - Optional DietPi software aliases/functions
	[[ -d '/var/lib/dietpi/dietpi-software/installed/dietpi-nordvpn' ]] && alias dietpi-nordvpn='/DietPi/dietpi/misc/dietpi-nordvpn'
	[[ -f '/opt/retropie/supplementary/emulationstation/emulationstation' ]] && alias emulationstation='/opt/retropie/supplementary/emulationstation/emulationstation'
	[[ -f '/usr/local/games/opentyrian/run' ]] && alias opentyrian='/usr/local/games/opentyrian/run'
	[[ -f $G_FP_DIETPI_USERDATA/dxx-rebirth/run.sh ]] && alias dxx-rebirth="$G_FP_DIETPI_USERDATA/dxx-rebirth/run.sh"
	[[ -f '/usr/share/applications/kodi.desktop' ]] && alias startkodi='/DietPi/dietpi/misc/start_kodi'
	[[ -f '/etc/systemd/system/dietpi-cloudshell.service' ]] && alias dietpi-cloudshell='/DietPi/dietpi/dietpi-cloudshell'
	[[ -d $G_FP_DIETPI_USERDATA/sonarr || -d $G_FP_DIETPI_USERDATA/radarr || -d $G_FP_DIETPI_USERDATA/lidarr ]] && alias dietpi-arr_to_RAM='/DietPi/dietpi/misc/dietpi-arr_to_RAM'
	# - occ/ncc need to be global function, as aliases are not accessible from non-interactive scripts:
	[[ -f '/var/www/owncloud/occ' ]] && occ(){ sudo -u www-data php /var/www/owncloud/occ "$@"; }
	[[ -f '/var/www/nextcloud/occ' ]] && ncc(){ sudo -u www-data php /var/www/nextcloud/occ "$@"; }

	#-----------------------------------------------------------------------------------
	# Whiptail (Whippy-da-whip-whip-whip tail!)
	# - Automatically detects/processes for G_INTERACTIVE
	#-----------------------------------------------------------------------------------
	# Input:
	# - G_WHIP_DEFAULT_ITEM		| Optional, to set the default selected/menu item or input box entry
	# - G_WHIP_SIZE_X_MAX=50	| Optional, limits X to value, if below available screen X limits
	# - G_WHIP_SIZE_[XY]_OVERRIDE	| Optional, X/Y sizes to override auto detection (e.g. no tput due to STDOUT+STDERR redirection), must be exported and unset after use.
	# - G_WHIP_BUTTON_OK_TEXT	| Optional, change as needed, defaults to "Ok"
	# - G_WHIP_BUTTON_CANCEL_TEXT	| Optional, change as needed, defaults to "Cancel"
	# - G_WHIP_MENU_ARRAY		| Required for G_WHIP_MENU to set available menu entries, 2 array indices per line: ('item' 'description')
	# - G_WHIP_CHECKLIST_ARRAY	| Required for G_WHIP_CHECKLIST set available checklist options, 3 array indices per line: ('item' 'description' 'on'/'off')
	# Output:
	# - G_WHIP_RETURNED_VALUE | Returned value from inputbox/menu/checklist based whiptail items

	# G_WHIP_DESTROY | Clear vars after run of whiptail
	G_WHIP_DESTROY(){

		unset WHIP_SIZE_X WHIP_SIZE_Y WHIP_SIZE_Z
		unset WHIP_BACKTITLE
		unset G_WHIP_DEFAULT_ITEM G_WHIP_SIZE_X_MAX
		unset G_WHIP_BUTTON_OK_TEXT G_WHIP_BUTTON_CANCEL_TEXT
		unset G_WHIP_MENU_ARRAY G_WHIP_CHECKLIST_ARRAY

	}
	# Run once, to be failsafe in case any exported/environment variables are left from originating shell
	G_WHIP_DESTROY

	# G_WHIP_INIT
	# - update target whiptail size, based on current screen dimensions.
	# - Used by G_WHIP_ automatically, doesn't need to be a global function, however, bash does not support local functions.
	# - $1 = input mode  0=no-Z 1=yes-Z (G_WHIP_MENU_ARRAY) 2=yes-Z (G_WHIP_CHECKLIST_ARRAY) 3=Force full size of Y
	G_WHIP_INIT(){

		# Set default button text, if not defined
		G_WHIP_BUTTON_OK_TEXT=${G_WHIP_BUTTON_OK_TEXT:-Ok}
		G_WHIP_BUTTON_CANCEL_TEXT=${G_WHIP_BUTTON_CANCEL_TEXT:-Cancel}

		# Update backtitle
		WHIP_BACKTITLE="$G_PROGRAM_NAME | $G_HW_MODEL_DESCRIPTION"
		[[ -r '/DietPi/dietpi/.network' ]] && WHIP_BACKTITLE+=" | IP: $(mawk 'NR==4 {print}' /DietPi/dietpi/.network)"

		# Automaticaly set size of whiptail box and contents
		local input_mode=$1

		# - Whip margins
		local whip_x_internal_margin=4
		local whip_y_internal_margin=6

		# - Text message lines required
		local lines_required_whip_y=0
		local lines_required_whip_z=0

		# Set current screen dimensions ( - outside margin)
		# - G_WHIP_SIZE_X_OVERRIDE allows to estimate and export terminal sizes outside of script/function
		#	This is required in case both, STOUT and STERR are redirected ( e.g. 2>&1 | tee file.log )
		#	Until ncurses-bin v6.0 (current on Stretch repo), tput can not estimate terminal dimensions then.
		#	With ncurses-bin v6.1 (current on Buster repo) this issue is resolved.
		WHIP_SIZE_X=$(( ${G_WHIP_SIZE_X_OVERRIDE:-$(tput cols)} - 6 ))
		if disable_error=1 G_CHECK_VALIDINT "$G_WHIP_SIZE_X_MAX" 1 $WHIP_SIZE_X; then

			WHIP_SIZE_X=$G_WHIP_SIZE_X_MAX

		elif (( $WHIP_SIZE_X > 120 )); then

			WHIP_SIZE_X=120

		fi

		WHIP_SIZE_Y=$(( ${G_WHIP_SIZE_Y_OVERRIDE:-$(tput lines)} - 4 ))
		(( $WHIP_SIZE_Y > 40 )) && WHIP_SIZE_Y=40

		WHIP_SIZE_Z=2

		# Force full size of Y?
		if (( $input_mode == 3 )); then

			lines_required_whip_y=$WHIP_SIZE_Y

		# Calulate lines required for WHIP_MESSAGE, as displayed inside the whiptail box
		# - This can then be used to increase/decrease size of WHIP_SIZE_Z automatically.
		else

			# - Calculate lines required, including addition lines, if the text is longer than X
			[[ $WHIP_MESSAGE ]] && while read -r line
			do

				(( lines_required_whip_y += 1 + ${#line} / ( $WHIP_SIZE_X - $whip_x_internal_margin) ))

			done <<< "$(echo -e "$WHIP_MESSAGE")"

			#	Process final whiptail size
			#	Add internal whiptail margins to end line total
			(( lines_required_whip_y += $whip_y_internal_margin ))

		fi

		# Calculate Z
		# - G_WHIP_MENU_ARRAY
		if (( $input_mode == 1 )); then

			# - ( ${#array} + 1 ) to round up on uneven array entries
			lines_required_whip_z=$(( ( ${#G_WHIP_MENU_ARRAY[@]} + 1 ) / 2 ))

			# - Requires additional line on Y
			((lines_required_whip_y++))

			# Auto length for ─
			#	Get max length of all the lines in odd number array 1st | '' 'this one'
			local i=0
			local character_count_max=0
			for (( i=1; i<${#G_WHIP_MENU_ARRAY[@]}; i+=2 ))
			do

				if (( ${#G_WHIP_MENU_ARRAY[$i]} > $character_count_max )); then

					character_count_max=${#G_WHIP_MENU_ARRAY[$i]}

					# - cap to X | need to calculate all length of array 1st...
					#if (( $character_count_max >= $WHIP_SIZE_X )); then

						#character_count_max=$WHIP_SIZE_X
						#break

					#fi

				fi

			done
			((character_count_max--)) # -1 for additional ●

			#	Now add the additional required lines
			for (( i=0; i<${#G_WHIP_MENU_ARRAY[@]}; i++ ))
			do

				if [[ ${G_WHIP_MENU_ARRAY[$i]} == '●'* ]]; then

					while (( ${#G_WHIP_MENU_ARRAY[$i]} < $character_count_max ))
					do

						G_WHIP_MENU_ARRAY[$i]+='─'

					done

					G_WHIP_MENU_ARRAY[$i]+='●'

				fi

			done

		# - G_WHIP_CHECKLIST_ARRAY
		elif (( $input_mode == 2 )); then

			# - ( ${#array} + 2 ) to round up single+double array entries
			lines_required_whip_z=$(( ( ${#G_WHIP_CHECKLIST_ARRAY[@]} + 2 ) / 3 ))

			# Auto length for ─
			#	Get max length of all the lines in array index 1 1st | '' 'this one' ''
			local i=0
			local character_count_max=0
			for (( i=1; i<${#G_WHIP_CHECKLIST_ARRAY[@]}; i+=3 ))
			do

				if (( ${#G_WHIP_CHECKLIST_ARRAY[$i]} > $character_count_max )); then

					character_count_max=${#G_WHIP_CHECKLIST_ARRAY[$i]}

					# - cap to X | need to calculate all length of array 1st...
					#if (( $character_count_max >= $WHIP_SIZE_X )); then

						#character_count_max=$WHIP_SIZE_X
						#break

					#fi

				fi

			done
			((character_count_max--)) # -1 for additional ●

			#	Now add the additional required lines
			for (( i=0; i<${#G_WHIP_CHECKLIST_ARRAY[@]}; i++ ))
			do

				if [[ ${G_WHIP_CHECKLIST_ARRAY[$i]} == '●'* ]]; then

					while (( ${#G_WHIP_CHECKLIST_ARRAY[$i]} < $character_count_max ))
					do

						#echo -e "${#G_WHIP_CHECKLIST_ARRAY[$i]} > $WHIP_LENGTH_AUTOLINEFILL | index=$i"
						G_WHIP_CHECKLIST_ARRAY[$i]+='─'

					done

					G_WHIP_CHECKLIST_ARRAY[$i]+='●'

				fi

			done

		fi

		# Calculate end result
		# - Message will not fit!
		if (( $lines_required_whip_y > $WHIP_SIZE_Y )); then

			G_DIETPI-NOTIFY 2 "Lines required for Whiptail box and its contents (y=$lines_required_whip_y, z=$lines_required_whip_z), exceeds screen dimensions (y=$WHIP_SIZE_Y)."

		# - Calculate a lower size of WHIP_SIZE_Y to fit everything and make it look nice!
		else

			# - Calc max size for lines_max_whip_z, based on lines_required_whip_y and current screen size
			if (( $lines_required_whip_z > 0 )); then

				local lines_max_whip_z=$lines_required_whip_z

				if (( ( $lines_max_whip_z + $lines_required_whip_y ) > $WHIP_SIZE_Y )); then

					lines_max_whip_z=$(( $WHIP_SIZE_Y - $lines_required_whip_y ))

					#	lines_max_whip_z < 1 indicates WHIP_SIZE_Y is too small to fit all message text and any lines_required_whip_z.
					#	So we must force lines_max_whip_z=1 resulting in some missing message text
					if (( $lines_max_whip_z < 1 )); then

						lines_max_whip_z=2
						G_DIETPI-NOTIFY 2 "Lines required for Whiptail box and its contents (y=$lines_required_whip_y, z=$lines_required_whip_z), exceeds screen dimensions (y=$WHIP_SIZE_Y)."

					fi

				fi

				WHIP_SIZE_Y=$(( $lines_required_whip_y + $lines_max_whip_z ))
				WHIP_SIZE_Z=$lines_max_whip_z

			else

				WHIP_SIZE_Y=$lines_required_whip_y

			fi

		fi

	}

	# G_WHIP_MSG "message"
	# - Display a whip message
	G_WHIP_MSG(){

		local WHIP_MESSAGE=$@

		if (( $G_INTERACTIVE )); then

			G_WHIP_INIT 0
			whiptail --title "$G_PROGRAM_NAME" --msgbox "$WHIP_MESSAGE" --ok-button "$G_WHIP_BUTTON_OK_TEXT" --backtitle "$WHIP_BACKTITLE" $WHIP_SIZE_Y $WHIP_SIZE_X

		else

			G_DIETPI-NOTIFY 2 "$WHIP_MESSAGE"

		fi

		G_WHIP_DESTROY

	}

	# G_WHIP_SCROLLBOX "message"
	# - Display a whip message inside a scrollbox
	G_WHIP_SCROLLBOX(){

		local WHIP_MESSAGE=$@

		if (( $G_INTERACTIVE )); then

			G_WHIP_INIT 0
			whiptail --title "$G_PROGRAM_NAME" --scrolltext --msgbox "$WHIP_MESSAGE" --ok-button "$G_WHIP_BUTTON_OK_TEXT" --backtitle "$WHIP_BACKTITLE" $WHIP_SIZE_Y $WHIP_SIZE_X

		else

			G_DIETPI-NOTIFY 2 "$WHIP_MESSAGE"

		fi

		G_WHIP_DESTROY

	}

	# G_WHIP_YESNO "message"
	# - Prompt user for a Yes/No, return result
	# - returns result 0=Ok, everything else considered a user cancelled result
	G_WHIP_YESNO(){

		local result=1

		if (( $G_INTERACTIVE )); then

			local WHIP_MESSAGE=$@
			G_WHIP_INIT 0
			local option_default_no='--defaultno'
			[[ ${G_WHIP_DEFAULT_ITEM,,} == 'yes' || ${G_WHIP_DEFAULT_ITEM,,} == 'ok' ]] && option_default_no=''
			whiptail --title "$G_PROGRAM_NAME" --yesno "$WHIP_MESSAGE" --backtitle "$WHIP_BACKTITLE" --yes-button "$G_WHIP_BUTTON_OK_TEXT" --no-button "$G_WHIP_BUTTON_CANCEL_TEXT" $option_default_no $WHIP_SIZE_Y $WHIP_SIZE_X
			result=$?

		fi

		G_WHIP_DESTROY
		return $result

	}

	# G_WHIP_INPUTBOX "message"
	# - Prompt user to input text and save it to G_WHIP_RETURNED_VALUE
	# - returns result 0=Ok, everything else considered a user cancelled result
	G_WHIP_INPUTBOX(){

		local result=1
		unset G_WHIP_RETURNED_VALUE # in case left from last G_WHIP

		if (( $G_INTERACTIVE )); then

			local WHIP_MESSAGE=$@
			G_WHIP_INIT 0
			G_WHIP_RETURNED_VALUE=$(whiptail --title "$G_PROGRAM_NAME" --inputbox "$WHIP_MESSAGE" --ok-button "$G_WHIP_BUTTON_OK_TEXT" --cancel-button "$G_WHIP_BUTTON_CANCEL_TEXT" --default-item "$G_WHIP_DEFAULT_ITEM" --backtitle "$WHIP_BACKTITLE" $WHIP_SIZE_Y $WHIP_SIZE_X "$G_WHIP_DEFAULT_ITEM" 3>&1 1>&2 2>&3-; echo $? > /tmp/.G_WHIP_INPUTBOX_RESULT)
			result=$(</tmp/.G_WHIP_INPUTBOX_RESULT); rm /tmp/.G_WHIP_INPUTBOX_RESULT
			if (( $result == 0 )) && [[ -z $G_WHIP_RETURNED_VALUE ]]; then

				result=1
				whiptail --title "$G_PROGRAM_NAME" --msgbox '[FAILED] An input value was not entered.' --backtitle "$WHIP_BACKTITLE" 9 60

			fi

		fi

		G_WHIP_DESTROY
		return $result

	}

	# G_WHIP_PASSWORD "message"
	# - Prompt user to input password and safe it in variable "result".
	# - Do not export for security reasons, instead run "unset result" after value has been handled in originating script!
	G_WHIP_PASSWORD(){

		local return_value=1
		result=''

		if (( $G_INTERACTIVE )); then

			local WHIP_MESSAGE=$@
			G_WHIP_INIT 0

			while :
			do

				local password_0=$(whiptail --title "$G_PROGRAM_NAME" --passwordbox "$WHIP_MESSAGE" --ok-button "$G_WHIP_BUTTON_OK_TEXT" --nocancel --backtitle "$WHIP_BACKTITLE" $WHIP_SIZE_Y $WHIP_SIZE_X 3>&1 1>&2 2>&3-)
				local password_1=$(whiptail --title "$G_PROGRAM_NAME" --passwordbox 'Please enter the new password again:' --ok-button "$G_WHIP_BUTTON_OK_TEXT" --nocancel --backtitle "$WHIP_BACKTITLE" $WHIP_SIZE_Y $WHIP_SIZE_X 3>&1 1>&2 2>&3-)
				if [[ $password_0 && $password_0 == "$password_1" ]]; then

					result=$password_0
					return_value=0
					break

				else

					whiptail --title "$G_PROGRAM_NAME" --msgbox '[FAILED] No password entered, or invalid match.\n\nPlease try again...' --ok-button 'Retry' --backtitle "$WHIP_BACKTITLE" 9 60

				fi

			done

		fi

		G_WHIP_DESTROY
		return $return_value

	}

	# G_WHIP_MENU "message"
	# - Prompt user to select option from G_WHIP_MENU_ARRAY and sets G_WHIP_RETURNED_VALUE
	# - returns result 0=Ok, everything else considered a user canceled result
	G_WHIP_MENU(){

		local result=1
		unset G_WHIP_RETURNED_VALUE # in case left from last G_WHIP

		if (( $G_INTERACTIVE )); then

			local WHIP_MESSAGE=$@
			G_WHIP_INIT 1
			G_WHIP_RETURNED_VALUE=$(whiptail --title "$G_PROGRAM_NAME" --menu "$WHIP_MESSAGE" --default-item "$G_WHIP_DEFAULT_ITEM" --ok-button "$G_WHIP_BUTTON_OK_TEXT" --cancel-button "$G_WHIP_BUTTON_CANCEL_TEXT" --backtitle "$WHIP_BACKTITLE" $WHIP_SIZE_Y $WHIP_SIZE_X $WHIP_SIZE_Z "${G_WHIP_MENU_ARRAY[@]}" 3>&1 1>&2 2>&3-; echo $? > /tmp/.WHIP_MENU_RESULT)
			result=$(</tmp/.WHIP_MENU_RESULT); rm /tmp/.WHIP_MENU_RESULT

		fi

		G_WHIP_DESTROY
		return $result

	}

	# G_WHIP_CHECKLIST "message"
	# - Prompt user to select multiple option from G_WHIP_CHECKLIST_ARRAY and sets G_WHIP_RETURNED_VALUE
	# - returns result 0=Ok, everything else considered a user canceled result
	G_WHIP_CHECKLIST(){

		local result=1
		unset G_WHIP_RETURNED_VALUE # in case left from last G_WHIP

		if (( $G_INTERACTIVE )); then

			local WHIP_MESSAGE=$@
			G_WHIP_INIT 2
			G_WHIP_RETURNED_VALUE=$(whiptail --title "$G_PROGRAM_NAME" --checklist "$WHIP_MESSAGE" --separate-output --default-item "$G_WHIP_DEFAULT_ITEM" --ok-button "$G_WHIP_BUTTON_OK_TEXT" --cancel-button "$G_WHIP_BUTTON_CANCEL_TEXT" --backtitle "$WHIP_BACKTITLE" $WHIP_SIZE_Y $WHIP_SIZE_X $WHIP_SIZE_Z "${G_WHIP_CHECKLIST_ARRAY[@]}" 3>&1 1>&2 2>&3-; echo $? > /tmp/.WHIP_CHECKLIST_RESULT)
			G_WHIP_RETURNED_VALUE=$(echo -e "$G_WHIP_RETURNED_VALUE" | tr '\n' ' ')
			result=$(</tmp/.WHIP_CHECKLIST_RESULT); rm /tmp/.WHIP_CHECKLIST_RESULT

		fi

		G_WHIP_DESTROY
		return $result

	}

	# G_WHIP_VIEWFILE /var/log/file.log
	# - Prompt user to view logfile, then display it as needed.
	G_WHIP_VIEWFILE(){

		local result=0

		if (( $G_INTERACTIVE )); then

			local log=${log:-0} # Optional yes/no prompt for viewing logs
			local fp_file=$1

			if [[ -f $fp_file ]]; then

				# - Log file view with prompt
				if (( $log )); then

					G_WHIP_YESNO "Would you like to view the contents of the following logfile?\n - $fp_file\n\nThis will contain further additional information, that may be required by the user."
					result=$?

				fi

				if (( ! $result )); then

					G_WHIP_INIT 3
					whiptail --title "$G_PROGRAM_NAME | File viewer" --textbox $fp_file --ok-button "$G_WHIP_BUTTON_OK_TEXT" --backtitle "$WHIP_BACKTITLE" --scrolltext $WHIP_SIZE_Y $WHIP_SIZE_X

				fi

			else

				G_WHIP_MSG "[FAILED] G_WHIP_VIEWFILE $fp_file\n - File does not exist."
				result=1

			fi

		fi

		G_WHIP_DESTROY
		return $result

	}

	#-----------------------------------------------------------------------------------
	# DietPi Error Handler
	# https://github.com/MichaIng/DietPi/issues/1311#issuecomment-353716344
	#-----------------------------------------------------------------------------------
	# Required input:
	# - G_ERROR_HANDLER_COMMAND=<cmd>		| Command name for print out
	# - G_ERROR_HANDLER_EXITCODE=<int>		| Commands exit code
	# Optional input:
	# - G_ERROR_HANDLER_NO_FAIL=1			| Always report a success, regardless of the exit code | G_INTERACTIVE=0 is not required for this
	# - G_ERROR_HANDLER_INFO_ONLY=1			| Only print info and retry options, no exit or bug report, sets G_ERROR_HANDLER_ONERROR_EXIT=0 automatically
	# - G_ERROR_HANDLER_ONERROR_EXIT=0		| Do not exit the script on error
	# - G_ERROR_HANDLER_RETRY=1			| Allow to retry the command. Requires loop in originating script!
	# - G_ERROR_HANDLER_ONERROR_FPLOGFILE=<path>	| File path to commands logfile, if available
	# - l_message					| Alternative text to print on success, less cryptic for end user
	# Output:
	# - G_ERROR_HANDLER_EXITCODE_RETURN=<int>	| Contains $G_ERROR_HANDLER_EXITCODE, but is not destroyed during G_ERROR_HANDLER_RESET(), allowing us to call afterwards

	# Runs automatically after G_ERROR_HANDLER to reset vars to default
	G_ERROR_HANDLER_RESET(){

		G_ERROR_HANDLER_EXITCODE_RETURN=$G_ERROR_HANDLER_EXITCODE

		# Delete logfile if used
		[[ $G_ERROR_HANDLER_ONERROR_FPLOGFILE && -f $G_ERROR_HANDLER_ONERROR_FPLOGFILE ]] && rm $G_ERROR_HANDLER_ONERROR_FPLOGFILE

		# Clear variables
		unset G_ERROR_HANDLER_COMMAND G_ERROR_HANDLER_EXITCODE
		unset G_ERROR_HANDLER_NO_FAIL G_ERROR_HANDLER_INFO_ONLY G_ERROR_HANDLER_ONERROR_EXIT
		unset G_ERROR_HANDLER_RETRY G_ERROR_HANDLER_ONERROR_FPLOGFILE l_message

	}

	# Handles exit code errors, as defined by G_ERROR_HANDLER_* settings
	G_ERROR_HANDLER(){

		[[ $l_message ]] || local l_message=$G_ERROR_HANDLER_COMMAND

		# Ok
		(( $G_ERROR_HANDLER_NO_FAIL )) && G_ERROR_HANDLER_EXITCODE=0
		if ! (( $G_ERROR_HANDLER_EXITCODE )); then

			G_DIETPI-NOTIFY 0 "$l_message"
			G_ERROR_HANDLER_RESET

		# Error
		else

			(( $G_ERROR_HANDLER_INFO_ONLY )) && G_ERROR_HANDLER_ONERROR_EXIT=0

			local send_bugreport=0
			local bugreport_id='N/A'
			local version_info="v$G_DIETPI_VERSION_CORE.$G_DIETPI_VERSION_SUB.$G_DIETPI_VERSION_RC ($G_GITOWNER/$G_GITBRANCH)"
			local print_hw_info="DietPi version: $version_info | HW_MODEL:$G_HW_MODEL | HW_ARCH:$G_HW_ARCH | DISTRO:$G_DISTRO"
			local image_creator='N/A'
			local preimage_name='N/A'
			if [[ -r '/DietPi/dietpi/.prep_info' ]]; then

				image_creator=$(mawk 'NR==1 {print}' /DietPi/dietpi/.prep_info)
				[[ $image_creator == 0 ]] && image_creator='DietPi Core Team'
				preimage_name=$(mawk 'NR==2 {print}' /DietPi/dietpi/.prep_info)

			fi

			local logfile_content='N/A'
			[[ $G_ERROR_HANDLER_ONERROR_FPLOGFILE ]] && logfile_content=$(tail -50 $G_ERROR_HANDLER_ONERROR_FPLOGFILE)
			local print_report_to_dietpi_info='If problems persist, please report at https://github.com/MichaIng/DietPi/issues for investigation.'
			local print_unable_to_continue="Unable to continue, $G_PROGRAM_NAME will now terminate."

			G_DIETPI-NOTIFY 1 "$G_ERROR_HANDLER_COMMAND"

			# Display "please report to dietpi", if it's one of our programs
			[[ $G_PROGRAM_NAME && $G_ERROR_HANDLER_INFO_ONLY != 1 ]] && G_DIETPI-NOTIFY 2 "$print_report_to_dietpi_info"

			# If interactive, prompt whip message
			if (( $G_INTERACTIVE )); then

				local whip_msg="${G_PROGRAM_NAME+$G_PROGRAM_NAME: }$G_ERROR_HANDLER_COMMAND
 - Exit code: $G_ERROR_HANDLER_EXITCODE
 - $print_hw_info
 - Image creator: $image_creator
 - Pre-image: $preimage_name"

				# Display logfile if available
				[[ $G_ERROR_HANDLER_ONERROR_FPLOGFILE ]] && whip_msg+="\n\nLog file content:\n$logfile_content"

				# Display "please report to dietpi", if its one of our programs
				[[ $G_PROGRAM_NAME && $G_ERROR_HANDLER_INFO_ONLY != 1 ]] && whip_msg+="\n\n$print_report_to_dietpi_info"

				[[ $G_ERROR_HANDLER_ONERROR_EXIT != 0 ]] && whip_msg+="\n\n$print_unable_to_continue"

				if (( $G_ERROR_HANDLER_RETRY )); then

					G_ERROR_HANDLER_RETRY=0

					local aretry_menu_options=('Retry' ': Re-run the last command that failed')
					local retry_menu_options_count=1

					if ! pgrep -cf 'dietpi-config' &> /dev/null && [[ $G_ERROR_HANDLER_INFO_ONLY != 1 ]]; then

						aretry_menu_options+=('DietPi-Config' ': Edit network, APT/NTP mirror settings etc'); ((retry_menu_options_count++))

					fi

					if [[ $G_PROGRAM_NAME && $G_ERROR_HANDLER_INFO_ONLY != 1 ]]; then

						aretry_menu_options+=('Send report' ': Uploads bugreport containing system info to DietPi'); ((retry_menu_options_count++))

					fi

					local no_button_text='Exit'
					[[ $G_ERROR_HANDLER_ONERROR_EXIT == 0 ]] && no_button_text='Ignore'

					local choice=$(whiptail --title 'DietPi Error Handler:' --menu "$whip_msg" --cancel-button "$no_button_text" --scrolltext 24 90 $retry_menu_options_count "${aretry_menu_options[@]}" 3>&1 1>&2 2>&3-)
					if (( $? == 0 )); then

						if [[ $choice == 'Retry' ]]; then

							G_ERROR_HANDLER_RETRY=1

						elif [[ $choice == 'DietPi-Config' ]]; then

							/DietPi/dietpi/dietpi-config
							G_ERROR_HANDLER_RETRY=1

						elif [[ $choice == 'Send report' ]]; then

							send_bugreport=1
							bugreport_id=$(mawk 'NR==5 {print}' /DietPi/dietpi/.hw_model)

						fi

					fi

				else

					whiptail --title 'DietPi Error Handler:' --msgbox "$whip_msg" --scrolltext 22 85

				fi

			# If non-interactive, never retry
			else

				G_ERROR_HANDLER_RETRY=0

			fi

			# GitHub printout
			if [[ $G_ERROR_HANDLER_INFO_ONLY != 1 ]]; then

				echo -e "
\e[41m
---------------------------------------------------------------------
- DietPi has encounted an error, and, is unable to continue         -
- Please create a ticket: https://github.com/MichaIng/DietPi/issues -
- Copy and paste the BLUE lines below, into the ticket              -
---------------------------------------------------------------------
\e[0m
\e[44m
#### Details:
- Date           | $(date)
- Bug report     | $bugreport_id
- DietPi version | $version_info
- Image creator  | $image_creator
- Pre-image      | $preimage_name
- SBC device     | $G_HW_MODEL_DESCRIPTION (index=$G_HW_MODEL)
- Kernel version | $(uname -a)
- Distro         | $G_DISTRO_NAME (index=$G_DISTRO)
- Command        | $G_ERROR_HANDLER_COMMAND
- Exit code      | $G_ERROR_HANDLER_EXITCODE
- Software title | $G_PROGRAM_NAME

#### Steps to reproduce:
<!-- Explain how to reproduce the issue -->
1. ...
2. ...

#### Expected behaviour:
<!-- What SHOULD happen? -->
- ...

#### Actual behaviour:
<!-- What IS happening? -->
- ...

#### Extra details:
<!-- Please post any extra details that might help solve the issue -->
- ...

#### Additional logs:
\`\`\`
$logfile_content
\`\`\`
\e[0m

\e[41m---------------------------------------------------------------------\e[0m
" > /tmp/.G_ERROR_HANDLER_GITREPORT

			fi

			if (( $send_bugreport )); then

				# Send automated bug report
				killall -qw dietpi-bugreport &> /dev/null
				/DietPi/dietpi/dietpi-bugreport 1

			fi

			# End
			if [[ $G_ERROR_HANDLER_RETRY != 1 ]]; then

				if [[ -f '/tmp/.G_ERROR_HANDLER_GITREPORT' ]]; then

					cat /tmp/.G_ERROR_HANDLER_GITREPORT
					rm /tmp/.G_ERROR_HANDLER_GITREPORT

				fi

				if [[ $G_ERROR_HANDLER_ONERROR_EXIT != 0 ]]; then

					G_DIETPI-NOTIFY 1 "$print_unable_to_continue"
					G_ERROR_HANDLER_RESET
					# Kill current script, excluding shell
					kill -INT $$

				else

					G_ERROR_HANDLER_RESET

				fi

			fi

		fi

		return $G_ERROR_HANDLER_EXITCODE_RETURN

	}

	# Run a command and send the output through the error handler. Allows for command used info, and log output/view when an error occurs
	#	NB: This command does not support inputs with redirects. For file creation, use G_FILE_EXISTS afterwards to check it exists: https://github.com/MichaIng/DietPi/issues/1311#issuecomment-354541417
	#	NB: automatically error handled (G_ERROR_HANDLER)
	#	$@ = input command
	#	eg: G_RUN_CMD mkdir /never/gonna/work
	G_RUN_CMD(){

		G_CHECK_ROOT_USER 1

		G_ERROR_HANDLER_COMMAND=$@

		G_ERROR_HANDLER_RETRY=1
		while (( $G_ERROR_HANDLER_RETRY ))
		do

			[[ $l_message ]] || local l_message=$G_ERROR_HANDLER_COMMAND
			G_DIETPI-NOTIFY -2 "$l_message"

			$G_ERROR_HANDLER_COMMAND &> /tmp/G_ERROR_HANDLER_COMMAND
			G_ERROR_HANDLER_EXITCODE=$?
			G_ERROR_HANDLER_ONERROR_FPLOGFILE='/tmp/G_ERROR_HANDLER_COMMAND'

			G_ERROR_HANDLER

			[[ -f '/tmp/G_ERROR_HANDLER_COMMAND' ]] && rm /tmp/G_ERROR_HANDLER_COMMAND

		done

		return $G_ERROR_HANDLER_EXITCODE_RETURN

	}

	# URL Connection test
	# - $@ = URL
	#	Optional variables:
	#	- $optional_cmd_inputs (eg: --no-check-certificate)
	#	- G_CHECK_URL_TIMEOUT to override default and dietpi.txt set timeout
	#	- G_CHECK_URL_ATTEMPTS to override default and dietpi.txt set attempts
	#	In case of failure and $G_INTERACTIVE=1: Prompts user to configure network
	G_CHECK_URL(){

		local url=$@
		local timeout=5
		if disable_error=1 G_CHECK_VALIDINT "$G_CHECK_URL_TIMEOUT" 0; then

			timeout=$G_CHECK_URL_TIMEOUT
			unset G_CHECK_URL_TIMEOUT

		elif [[ -f '/DietPi/dietpi.txt' ]]; then

			timeout=$(grep -m1 '^[[:blank:]]*CONFIG_G_CHECK_URL_TIMEOUT=' /DietPi/dietpi.txt | sed 's/^[^=]*=//')
			disable_error=1 G_CHECK_VALIDINT "$timeout" 0 || timeout=5

		fi
		local attempts=3
		if disable_error=1 G_CHECK_VALIDINT "$G_CHECK_URL_ATTEMPTS" 0; then

			attempts=$G_CHECK_URL_ATTEMPTS
			unset G_CHECK_URL_ATTEMPTS

		elif [[ -f '/DietPi/dietpi.txt' ]]; then

			attempts=$(grep -m1 '^[[:blank:]]*CONFIG_G_CHECK_URL_ATTEMPTS=' /DietPi/dietpi.txt | sed 's/^[^=]*=//')
			disable_error=1 G_CHECK_VALIDINT "$attempts" 0 || attempts=3

		fi

		while :
		do

			G_ERROR_HANDLER_COMMAND="Connection test: $url"
			G_ERROR_HANDLER_ONERROR_FPLOGFILE='/tmp/G_CHECK_URL'
			G_ERROR_HANDLER_RETRY=1

			G_DIETPI-NOTIFY -2 "Testing connection to $url, please wait..."

			local i=0
			for ((i=1; i<=$attempts; i++))
			do

				# Since --tries/-t is not applied on "fatal" errors (resolving failed, connection refused, 404), we need to loop ourself to exclude any temporary issue
				wget --spider -t 1 -T $timeout $optional_cmd_inputs "$url" &> $G_ERROR_HANDLER_ONERROR_FPLOGFILE
				G_ERROR_HANDLER_EXITCODE=$?

				# Valid
				(( $G_ERROR_HANDLER_EXITCODE )) || break

				# Retry
				G_DIETPI-NOTIFY -2 "Failed connection attempt to $url ($i/$attempts), retrying..."
				sleep 1

			done

			G_ERROR_HANDLER
			(( $G_ERROR_HANDLER_EXITCODE )) || break

		done

		return $G_ERROR_HANDLER_EXITCODE_RETURN

	}

	# $1 = directory to test permissions support
	# Returns 0=ok >=1=failed
	G_CHECK_FS_PERMISSION_SUPPORT(){

		local input=$1
		local result=1

		while :
		do

			if ! mkdir -p $input; then

				G_WHIP_MSG "Error creating directory $input, unable to check filesystem permissions"
				break

			fi

			local fp_target="$input/.test"
			if ! > $fp_target; then

				G_WHIP_MSG "Error creating test file $fp_target, unable to check filesystem permissions"
				break

			fi

			# - Apply and check permissions support, twice (just incase the current value is already set)
			local permissions_failed=0

			chmod 600 $fp_target
			if [[ $(stat -c "%a" $fp_target) != '600' ]]; then

				permissions_failed=1

			else

				chmod 644 $fp_target
				[[ $(stat -c "%a" $fp_target) != '644' ]] && permissions_failed=1

			fi

			if (( $permissions_failed )); then

				G_WHIP_MSG "ERROR: Filesystem does not support permissions (eg: FAT16/32):\n\n$fp_target\n\nPlease select a different drive and/or format it with ext4, ensuring support for filesystem permissions.\n\nUnable to continue, aborting..."
				break

			fi

			# - else ok
			result=0

			break

		done

		[[ -f $fp_target ]] && rm $fp_target
		return $result

	}

	# Checks if a file/folder exists
	G_FILE_EXISTS(){

		G_ERROR_HANDLER_COMMAND=$@

		G_DIETPI-NOTIFY -2 "Checking for existance: $G_ERROR_HANDLER_COMMAND"

		local string

		if [[ -f $G_ERROR_HANDLER_COMMAND ]]; then

			string='File exists'

		elif [[ -d $G_ERROR_HANDLER_COMMAND ]]; then

			string='Folder exists'

		else

			string='File/folder does not exist'
			G_ERROR_HANDLER_EXITCODE=1

		fi

		string+=" | $G_ERROR_HANDLER_COMMAND"

		echo -e "$string" > /tmp/G_ERROR_HANDLER_COMMAND
		G_ERROR_HANDLER_ONERROR_FPLOGFILE='/tmp/G_ERROR_HANDLER_COMMAND'
		G_ERROR_HANDLER_COMMAND=$string

		G_ERROR_HANDLER

		[[ -f '/tmp/G_ERROR_HANDLER_COMMAND' ]] && rm /tmp/G_ERROR_HANDLER_COMMAND

	}

	#-----------------------------------------------------------------------------------
	# APT
	#-----------------------------------------------------------------------------------
	G_FP_LOG_APT='/var/tmp/dietpi/logs/dietpi-software_apt.log'

	# apt-get install
	#	NB: automatically error handled (G_ERROR_HANDLER)
	G_AGI(){

		G_CHECK_ROOT_USER 1

		local string=$@
		local options='--allow-change-held-packages'

		G_ERROR_HANDLER_RETRY=1
		while (( $G_ERROR_HANDLER_RETRY ))
		do

			G_ERROR_HANDLER_COMMAND="G_AGI $string"
			G_ERROR_HANDLER_ONERROR_FPLOGFILE=$G_FP_LOG_APT

			# -qq can add a slight period of appearing nothing is happening, lets inform user
			G_DIETPI-NOTIFY 2 "\e[0mAPT installation for: \e[33m$string\e[0m, please wait..."

			echo -ne '\e[90m'
			DEBIAN_FRONTEND=noninteractive apt-get -qq $options install $string 2>&1 | tee $G_FP_LOG_APT
			G_ERROR_HANDLER_EXITCODE=${PIPESTATUS[0]}

			G_ERROR_HANDLER

		done

		return $G_ERROR_HANDLER_EXITCODE_RETURN

	}

	# apt-get purge
	#	NB: automatically error handled (G_ERROR_HANDLER)
	G_AGP(){

		G_CHECK_ROOT_USER 1

		local string=$@
		local options='--allow-change-held-packages'

		G_ERROR_HANDLER_RETRY=1
		while (( $G_ERROR_HANDLER_RETRY ))
		do

			G_ERROR_HANDLER_COMMAND="G_AGP $string"
			G_ERROR_HANDLER_ONERROR_FPLOGFILE=$G_FP_LOG_APT

			G_DIETPI-NOTIFY 2 "\e[0mAPT removal for: \e[33m$string\e[0m, please wait..."

			# - Create one-lined list of matching installed packages, abort if none were found
			local packages=$(dpkg --get-selections $string 2> /dev/null | mawk '{print $1}' ORS=' ')
			if [[ $packages ]]; then

				echo -ne '\e[90m'
				DEBIAN_FRONTEND=noninteractive apt-get -qq $options purge $packages 2>&1 | tee $G_FP_LOG_APT
				G_ERROR_HANDLER_EXITCODE=${PIPESTATUS[0]}

			else

				G_DIETPI-NOTIFY 2 'None of the requested packages are currently installed. Aborting...'
				G_ERROR_HANDLER_EXITCODE=0

			fi

			G_ERROR_HANDLER

		done

		return $G_ERROR_HANDLER_EXITCODE_RETURN

	}

	# apt-get autoremove
	#	NB: automatically error handled (G_ERROR_HANDLER)
	G_AGA(){

		G_CHECK_ROOT_USER 1

		G_ERROR_HANDLER_RETRY=1
		while (( $G_ERROR_HANDLER_RETRY ))
		do

			G_ERROR_HANDLER_COMMAND='G_AGA'
			G_ERROR_HANDLER_ONERROR_FPLOGFILE=$G_FP_LOG_APT

			G_DIETPI-NOTIFY 2 '\e[0mAPT autoremove + purge, please wait...'

			echo -ne '\e[90m'
			DEBIAN_FRONTEND=noninteractive apt-get -qq --purge autoremove 2>&1 | tee $G_FP_LOG_APT
			G_ERROR_HANDLER_EXITCODE=${PIPESTATUS[0]}

			G_ERROR_HANDLER

		done

		return $G_ERROR_HANDLER_EXITCODE_RETURN

	}

	# apt-get -f install
	#	NB: automatically error handled (G_ERROR_HANDLER)
	G_AGF(){

		G_CHECK_ROOT_USER 1

		local options='--allow-change-held-packages'

		G_ERROR_HANDLER_RETRY=1
		while (( $G_ERROR_HANDLER_RETRY ))
		do

			G_ERROR_HANDLER_COMMAND='G_AGF'
			G_ERROR_HANDLER_ONERROR_FPLOGFILE=$G_FP_LOG_APT

			G_DIETPI-NOTIFY 2 '\e[0mAPT fix, please wait...'

			echo -ne '\e[90m'
			DEBIAN_FRONTEND=noninteractive apt-get -qq $options -f install 2>&1 | tee $G_FP_LOG_APT
			G_ERROR_HANDLER_EXITCODE=${PIPESTATUS[0]}

			G_ERROR_HANDLER

		done

		return $G_ERROR_HANDLER_EXITCODE_RETURN

	}

	# apt-get clean + update
	#	NB: automatically error handled (G_ERROR_HANDLER)
	G_AGUP(){

		G_CHECK_ROOT_USER 1

		G_ERROR_HANDLER_RETRY=1
		while (( $G_ERROR_HANDLER_RETRY ))
		do

			G_ERROR_HANDLER_COMMAND='G_AGUP'
			G_ERROR_HANDLER_ONERROR_FPLOGFILE=$G_FP_LOG_APT

			G_DIETPI-NOTIFY 2 '\e[0mAPT update, please wait...'

			echo -ne '\e[90m'
			DEBIAN_FRONTEND=noninteractive apt-get clean 2>&1 | tee $G_FP_LOG_APT
			DEBIAN_FRONTEND=noninteractive apt-get -q update 2>&1 | tee -a $G_FP_LOG_APT
			G_ERROR_HANDLER_EXITCODE=${PIPESTATUS[0]}

			G_ERROR_HANDLER

		done

		return $G_ERROR_HANDLER_EXITCODE_RETURN

	}

	# apt-get upgrade
	#	NB: automatically error handled (G_ERROR_HANDLER)
	G_AGUG(){

		G_CHECK_ROOT_USER 1

		G_ERROR_HANDLER_RETRY=1
		while (( $G_ERROR_HANDLER_RETRY ))
		do

			G_ERROR_HANDLER_COMMAND='G_AGUG'
			G_ERROR_HANDLER_ONERROR_FPLOGFILE=$G_FP_LOG_APT

			G_DIETPI-NOTIFY 2 '\e[0mAPT upgrade, please wait...'

			echo -ne '\e[90m'
			DEBIAN_FRONTEND=noninteractive apt-get -qq upgrade 2>&1 | tee $G_FP_LOG_APT
			G_ERROR_HANDLER_EXITCODE=${PIPESTATUS[0]}

			G_ERROR_HANDLER

		done

		return $G_ERROR_HANDLER_EXITCODE_RETURN

	}

	# apt-get dist-upgrade
	#	NB: automatically error handled (G_ERROR_HANDLER)
	G_AGDUG(){

		G_CHECK_ROOT_USER 1

		local options='--allow-change-held-packages'

		G_ERROR_HANDLER_RETRY=1
		while (( $G_ERROR_HANDLER_RETRY ))
		do

			G_ERROR_HANDLER_COMMAND='G_AGDUG'
			G_ERROR_HANDLER_ONERROR_FPLOGFILE=$G_FP_LOG_APT

			G_DIETPI-NOTIFY 2 '\e[0mAPT dist-upgrade, please wait...'

			echo -ne '\e[90m'
			DEBIAN_FRONTEND=noninteractive apt-get -qq $options dist-upgrade 2>&1 | tee $G_FP_LOG_APT
			G_ERROR_HANDLER_EXITCODE=${PIPESTATUS[0]}

			G_ERROR_HANDLER

		done

		return $G_ERROR_HANDLER_EXITCODE_RETURN

	}

	# Checks for required APT packages, installs if needed.
	# $@ = list of required packages
	#	NB: automatically error handled (G_ERROR_HANDLER)
	G_AG_CHECK_INSTALL_PREREQ(){

		G_CHECK_ROOT_USER 1

		local exit_code=0
		local string=$@
		local i packages

		G_DIETPI-NOTIFY 2 "Checking for required APT packages: \e[33m$string"

		for i in $string
		do

			dpkg-query -s "$i" &> /dev/null && continue
			G_DIETPI-NOTIFY 2 "Flagged for install: \e[33m$i"
			packages+=" $i"

		done

		if [[ $packages ]]; then

			G_AGUP
			G_AGI $packages
			exit_code=$?

		else

			G_DIETPI-NOTIFY 0 'All required APT packages are already installed.'

		fi

		return $exit_code

	}

	#-----------------------------------------------------------------------------------
	# MISC: Commands
	#-----------------------------------------------------------------------------------
	# Treesize
	# - $1 = Optional input directory (eg: G_TREESIZE /etc/apt)
	G_TREESIZE(){

		G_CHECK_ROOT_USER 1

		du -k --max-depth=1 $1 | sort -nr | mawk '
		BEGIN {
			split("KB,MB,GB,TB", Units, ",");
		}
		{
			u = 1;
			while ($1 >= 1024)
			{
				$1 = $1 / 1024;
				u += 1;
			}
			$1 = sprintf("%.1f %s", $1, Units[u]);
			print $0;
		}
		'
	}

	# Returns current CPU temp 'C
	# - print_full_info=1	Optional input to print full colour text output and temp warnings
	G_OBTAIN_CPU_TEMP(){

		# Read CPU temp from file
		local temp
		# - Sparky/Asus: Requires special case as in others array this would break other SBC temp readouts with 2 zones
		if (( $G_HW_MODEL == 70 || $G_HW_MODEL == 52 )); then

			[[ -f '/sys/class/thermal/thermal_zone1/temp' ]] && temp=$(</sys/class/thermal/thermal_zone1/temp)

		# - Others
		else

			# Array to store possible locations for temp read
			local afp_temperature=(

				'/sys/class/thermal/thermal_zone0/temp'
				'/sys/devices/platform/sunxi-i2c.0/i2c-0/0-0034/temp1_input'
				'/sys/class/hwmon/hwmon0/device/temp_label'
				'/sys/class/hwmon/hwmon0/temp2_input'

			)

			for i in ${afp_temperature[@]}
			do

				[[ -f $i ]] && { temp=$(<$i); break; }

			done

		fi

		# Format output
		# - Check for valid value: We must always return a value, due to VM lacking this feature + benchmark online
		if ! disable_error=1 G_CHECK_VALIDINT "$temp"; then

			temp='N/A'

		else

			# 2/5 digit output?
			(( $temp >= 150 )) && temp=$(mawk '{print $1/1000}' <<< $temp | xargs printf "%0.0f")

			if [[ $print_full_info == 1 ]]; then

				local temp_f=$(( $temp * 9/5 + 32 ))
				if (( $temp >= 70 )); then

					temp="\e[1;31mWARNING: $temp'C : $temp_f'F (Reducing the life of your device)\e[0m"

				elif (( $temp >= 60 )); then

					temp="\e[38;5;202m$temp'C : $temp_f'F \e[90m(Running hot, not recommended)\e[0m"

				elif (( $temp >= 50 )); then

					temp="\e[1;33m$temp'C : $temp_f'F \e[90m(Running warm, but safe)\e[0m"

				elif (( $temp >= 40 )); then

					temp="\e[1;32m$temp'C : $temp_f'F \e[90m(Optimal temperature)\e[0m"

				elif (( $temp >= 30 )); then

					temp="\e[1;36m$temp'C : $temp_f'F \e[90m(Cool runnings)\e[0m"

				else

					temp="\e[1;36m$temp'C : $temp_f'F \e[90m(Who put me in the freezer!)\e[0m"

				fi

			fi

		fi

		echo -e "$temp"

	}

	# Returns current CPU usage %
	G_OBTAIN_CPU_USAGE(){

		# PS (inaccurate, but fast??)
		local cpu_usage=0
		while read -r line
		do

			cpu_usage=$(bc -l <<< "scale=1;$cpu_usage + $line")

		done <<< "$(ps -eo %cpu | sed -n '1!{s/^ //p}')"

		# ps returns usage of each core, so we devide the total by #n cores
		cpu_usage=$(bc -l <<< "scale=1;$cpu_usage / $G_HW_CPU_CORES")

		echo $cpu_usage

	}

	# Check available free space on path, against input value (MiB)
	# - Returns 0=Ok, 1=insufficient space available
	#	If $2 is not used, returns available space in MiB | info_autoscale=1 # Scales MiB to GiB if required and prints unit
	# - $1 = path
	# - $2 = Optional, free space (MiB)
	#	EG: if (( $(G_CHECK_FREESPACE /path 100) )); then
	G_CHECK_FREESPACE(){

		local info_autoscale=${info_autoscale:-0}
		local return_value=1
		local input_path=$1
		local input_required_space=$2
		local available_space=$(df -m --output=avail $input_path | mawk 'NR==2 {print $1;exit}')

		if [[ ! $input_required_space ]]; then

			if (( $info_autoscale )); then

				(( $available_space > 9999 )) && available_space="$(( $available_space / 1024 )) GiB" || available_space+=' MiB'

			fi

			echo $available_space
			return_value=0

		elif ! disable_error=1 G_CHECK_VALIDINT $available_space; then

			G_WHIP_MSG 'G_CHECK_FREESPACE: invalid integer from df result'

		else

			(( $available_space > $input_required_space )) && return_value=0
			G_DIETPI-NOTIFY $return_value "Free space check: path=$input_path | available=$available_space MiB | required=$input_required_space MiB"

		fi

		return $return_value

	}

	# G_CHECK_VALIDINT | Simple test to verify if a variable is a valid integer.
	# $1=input
	# $2=Optional Min value range
	# $3=Optional Max value range
	#	disable_error=1 to disable notify/whiptail invalid value when recieved
	# 1=no | scripts killed automatically
	# 0=yes
	# Usage = if G_CHECK_VALIDINT input; then
	G_CHECK_VALIDINT(){

		local return_value=1
		local input=$1
		local min=$2
		local max=$3
		[[ $disable_error == 1 ]] || local disable_error=0

		if [[ $input =~ ^-?[0-9]+$ ]]; then

			if [[ $min =~ ^-?[0-9]+$ ]]; then

				if (( $input >= $min )); then

					if [[ $max =~ ^-?[0-9]+$ ]]; then

						if (( $input <= $max )); then

							return_value=0

						elif (( ! $disable_error )); then

							G_WHIP_MSG "Input value \"$input\" is higher than allowed \"$max\". No changes applied."

						fi

					else

						return_value=0

					fi

				elif (( ! $disable_error )); then

					G_WHIP_MSG "Input value \"$input\" is lower than allowed \"$min\". No changes applied."

				fi

			else

				return_value=0

			fi

		elif (( ! $disable_error )); then

			G_WHIP_MSG "Invalid input value \"$input\". No changes applied."

		fi

		unset disable_error
		return $return_value

	}

	# Verifies the integrity of the DietPi userdata folder/symlink, based on where it should be psyhically. Basically, checks if user removed the USB drive with userdata on it.
	#	NB: As this is considered a critical (if failed), current scripts will be exited automatically
	# 1=fail
	# 0=ok
	G_CHECK_USERDATA(){

		local return_value=0
		local fp_actual=$G_FP_DIETPI_USERDATA

		# Symlinked?
		if [[ -L $G_FP_DIETPI_USERDATA ]]; then

			# Check psyhical location exists and is mounted
			fp_actual=$(readlink -f $G_FP_DIETPI_USERDATA)
			df -P $fp_actual &> /dev/null || return_value=1

		fi

		G_DIETPI-NOTIFY $return_value "DietPi-Userdata validation: $fp_actual"
		if (( $return_value )); then

			G_WHIP_MSG "[FAILED] DietPi-Userdata validation\n\nDietPi was unable to verify the existance of the userdata directory ($fp_actual).\n\nPlease ensure all previous external drives are connected and functional, before trying again.\n\nUnable to continue, exiting."
			kill -INT $$ # kill all current scripts, excluding shell

		fi

		return $return_value

	}

	# Prompt user to create a backup before system changes. Exit existing scripts if failed.
	G_PROMPT_BACKUP_DISABLED=${G_PROMPT_BACKUP_DISABLED:-0}
	G_PROMPT_BACKUP(){

		if (( ! $G_PROMPT_BACKUP_DISABLED )); then

			G_WHIP_YESNO "Would you like to create (or update) a 'DietPi-Backup' of the system, before proceeding?\n\n'DietPi-Backup' creates a system restore point, which can be recovered if unexpected issues occur.\n\nFor more information on 'DietPi-Backup', please use the link below:\n - https://dietpi.com/phpbb/viewtopic.php?f=8&t=5&start=30#p255"
			if (( $? == 0 )); then

				/DietPi/dietpi/dietpi-backup 1
				local exit_code=$?

				G_DIETPI-NOTIFY -1 $exit_code 'DietPi-Backup'
				if (( $exit_code )); then

					# - Kill current scripts, excluding shell
					G_WHIP_MSG 'DietPi-Backup was unable to complete sucessfully. To avoid issues, the current program will now be terminated.\n - logfile = /var/log/dietpi-backup.log'
					kill -INT $$

				fi

			fi

		fi

	}

	# If file/folder exists, backup to *.bak_DDMMYYY
	G_BACKUP_FP(){

		local ainput_string=("$@")
		local fp_db_log='/var/tmp/dietpi/logs/G_BACKUP_FP.db'
		local print_fp_db_info=0

		local i
		for i in "${ainput_string[@]}"
		do

			if [[ -e $i ]]; then

				local fp_backup_target="$i.bak_$(date +%d%m%y)"
				local index=0
				while [[ -e ${fp_backup_target}_$index ]]
				do

					((index++))

				done

				local notify_code=1
				if cp -a $i ${fp_backup_target}_$index; then

					notify_code=0
					print_fp_db_info=1
					echo "${fp_backup_target}_$index # $G_PROGRAM_NAME" >> $fp_db_log

				fi

				G_DIETPI-NOTIFY $notify_code "$i: backup to ${fp_backup_target}_$index"

			fi

		done

		(( $print_fp_db_info )) && G_DIETPI-NOTIFY 2 "For a full list of backup items, please see $fp_db_log"

	}

	#-----------------------------------------------------------------------------------
	# Multithreading handler
	#-----------------------------------------------------------------------------------
	# Not yet compatible with dietpi global commands. single bash commands only with no error handling.
	G_THREADING_ENABLED=${G_THREADING_ENABLED:-1}

	G_THREAD_START(){

		# - Launch as BG process
		if (( $G_THREADING_ENABLED )); then

			[[ $G_THREAD_COUNT =~ ^[0-9]+$ ]] || G_THREAD_COUNT=-1
			((G_THREAD_COUNT++))
			G_THREAD_COMMAND[$G_THREAD_COUNT]=$@

			echo -1337 > /tmp/.G_THREAD_EXITCODE_$G_THREAD_COUNT
			{ { G_INTERACTIVE=0 ${G_THREAD_COMMAND[$G_THREAD_COUNT]} &> /tmp/.G_THREAD_COMMAND_$G_THREAD_COUNT; echo $? > /tmp/.G_THREAD_EXITCODE_$G_THREAD_COUNT; } & disown; } &> /dev/null

			G_DIETPI-NOTIFY 2 "G_THREAD_START_$G_THREAD_COUNT | ${G_THREAD_COMMAND[$G_THREAD_COUNT]}"

		# - Run in blocking mode
		else

			local command=$@
			G_DIETPI-NOTIFY 2 "G_THREADING disabled, running command in blocking mode | $command"
			$command

		fi

	}

	G_THREAD_WAIT(){

		#local wait_for_specific_thread_pid=-1
		#[[ $1 ]] && wait_for_specific_thread_pid=$1

		local thread_active i waiting=-1

		while :
		do

			thread_active=0

			for i in ${!G_THREAD_COMMAND[@]}
			do

				if [[ -f /tmp/.G_THREAD_EXITCODE_$i && $(</tmp/.G_THREAD_EXITCODE_$i) == -1337 ]]; then

					(( $waiting == $i )) || G_DIETPI-NOTIFY -2 "G_THREAD_WAIT_$i | ${G_THREAD_COMMAND[$i]}"
					thread_active=1
					break

				fi

			done

			(( $thread_active )) || break

			waiting=$i
			sleep 1

		done

		G_DIETPI-NOTIFY 0 'G_THREAD: All threads finished'

		# - Check all thread exit codes for issues
		for i in ${!G_THREAD_COMMAND[@]}
		do

			if [[ -r /tmp/.G_THREAD_EXITCODE_$i ]]; then

				local exit_code=$(</tmp/.G_THREAD_EXITCODE_$i)
				(( $exit_code )) && G_WHIP_MSG "G_THREAD ERROR:\n - Command = ${G_THREAD_COMMAND[$i]}\n - Exit code = $exit_code\n\n$(</tmp/.G_THREAD_COMMAND_$i)"

			else

				G_DIETPI-NOTIFY 2 "DEBUG: /tmp/.G_THREAD_EXITCODE_$i does not exist or not readable"

			fi

		done

		rm -f /tmp/.G_THREAD*
		unset G_THREAD_COUNT G_THREAD_COMMAND

	}

	#-----------------------------------------------------------------------------------
	# DEV tools (Not for public use! All mine! :D)
	#-----------------------------------------------------------------------------------
	# Restore backup and update DietPi to latest development branch code
	# - Restore backup
	# - Set dev branch
	# - Update DietPi, setting subversion code -1
	# - Update backup
	G_DEV_1(){

		G_CHECK_ROOT_USER 1

		export G_INTERACTIVE=0
		/DietPi/dietpi/dietpi-backup -1
		G_CONFIG_INJECT 'DEV_GITBRANCH=' 'DEV_GITBRANCH=dev' /DietPi/dietpi.txt
		/DietPi/dietpi/dietpi-update -1
		/DietPi/dietpi/dietpi-backup 1

		unset G_INTERACTIVE

	}

	# Apply and update to different branch
	G_DEV_BRANCH(){

		G_CHECK_ROOT_USER 1
		G_CONFIG_INJECT 'DEV_GITBRANCH=' "DEV_GITBRANCH=$1" /DietPi/dietpi.txt
		/DietPi/dietpi/dietpi-update -1

	}

	# Automatically opt in to DietPi-Survey and run + send benchmark + data
	G_DEV_BENCH(){

		echo 1 > /DietPi/dietpi/.dietpi-survey
		G_INTERACTIVE=0 /DietPi/dietpi/func/dietpi-benchmark 2

	}

	# Inject setting into config file: First tries to replace old setting, else commented setting and otherwise adds to end of file.
	# Usage:
	# - $1 Setting pattern to find existing setting with grep extended regular expression support
	# - $2 Target setting + value, to inject into config file: After bash string expansion (e.g. variables), everything else will be taken literally, thus no further escaping is required.
	# - $3 Path to config file
	# - Optional: $4 Line pattern after which the setting will be added instead of end of file with grep extended regular expression support
	# - GCI_PASSWORD=1 G_CONFIG_INJECT, password entry, do not print raw output to screen.
	# - GCI_PRESERVE=1 G_CONFIG_INJECT preserves current setting, if present.
	# - GCI_BACKUP=1 G_CONFIG_INJECT creates a backup before editing the file, if backup does not yet exist, to: $3.bak
	# - GCI_NEWLINE=1 G_CONFIG_INJECT explicitly expands newlines \n within $2, which by default are taken literally
	#	- Be careful with this, since pattern matching is only done per line which can lead to doubled lines when applying G_CONFIG_INJECT a second time.
	# NB:
	# - Within double quotes "", as usual, escape literally meant double quotes and dollar signs $ with leading backslash \.
	# - Within single quotes '', as usual, escape literally meant single quotes via: '\'' # End leading string; Add escaped single quote; Start trailing string
	# - Additionally in case of extended regular expression support ($1 and $4), the following characters need to be escaped via backslash \, if wanted literally:
	#	\ . + * ? [ ( { ^ & $ |
	# Example:
	# - G_CONFIG_INJECT 'prefer-family[[:blank:]=]' 'prefer-family = IPv4' /etc/wgetrc
	G_CONFIG_INJECT(){

		[[ $G_PROGRAM_NAME ]] || local G_PROGRAM_NAME='G_CONFIG_INJECT'
		local pattern=${1//\//\\\/}
		local setting_raw=$2
		local setting=${2//\\/\\\\}; setting=${setting//./\\.}; setting=${setting//+/\\+}; setting=${setting//\*/\\\*}; setting=${setting//\?/\\\?}; setting=${setting//[/\\[}
		setting=${setting//\(/\\\(}; setting=${setting//\{/\\\{}; setting=${setting//^/\\^}; setting=${setting//&/\\&}; setting=${setting//$/\\$}; setting=${setting//|/\\|}; setting=${setting//\//\\\/}
		[[ $GCI_NEWLINE == 1 ]] && setting=${setting//\\\\n/\\n}
		local file=$3
		local after=${4//\//\\\/}
		local error=''

		# Replace password string by asterisks in output string
		if [[ $GCI_PASSWORD == 1 ]]; then

			local password=''
			password=$(sed -E "s/^.*$pattern[[:blank:]]*//" <<< "$setting_raw")
			setting_raw="$(sed -E "s/(^.*$pattern[[:blank:]]*).*$/\1/" <<< "$setting_raw")${password//?/*}"
			unset password

		fi

		syntax_error(){

			[[ $after ]] && after="after line \$4\n	$after (raw escaped input)\n"
			[[ $error ]] && error="\n\"grep\" or \"sed\" reported the following error:\n	$error\n"

			G_WHIP_MSG "[FAILED] Syntax error
$error
Couldn't add setting \$2
	$setting (escaped input)
into file \$3
	$file
$after
NB:
 - Within double quotes \"\", as usual, escape literally meant double quotes and dollar signs \$ via:
 	\\\" respectively \\\$
 - Within single quotes '', as usual, escape literally meant single quotes via:
 	'\'' # <End leading string>; <Add escaped single quote>; <Start trailing string>
 - Additionally in case of extended regular expression support (\$1 and \$4), the following characters need to be escaped via backslash \, if wanted literally:
	\ . + * ? [ ( { ^ & $ |
 - Do not escape forward slashes /, which will be done internally for all arguments!"

			unset syntax_error

		}

		if [[ ! -w $file ]]; then

			G_WHIP_MSG "[FAILED] File does not exist or cannot be written to by current user\n
Please verify the existence of the file \$3
	$file\n
Retry with proper permissions or apply the setting manually:
	$setting_raw"

		elif error=$(grep -Eq "^[[:blank:]]*$pattern" $file 2>&1); then
			# As an error within the condition leads to result "false", it can be caught only in next "elif"/"else" statement.

			if [[ $GCI_PRESERVE == 1 ]]; then

				G_DIETPI-NOTIFY 0 "Current setting in \e[33m$file\e[0m will be preserved: \e[33m$([[ $GCI_PASSWORD == 1 ]] && echo "${setting_raw//\\/\\\\}" || grep -Em1 "^[[:blank:]]*$pattern" $file | sed 's|\\|\\\\|g')\e[0m"

			elif error=$(grep -Eq "^[[:blank:]]*$setting([[:space:]]|$)" $file 2>&1); then

				G_DIETPI-NOTIFY 0 "Desired setting in \e[33m$file\e[0m was already set: \e[33m$([[ $GCI_PASSWORD == 1 ]] && echo "${setting_raw//\\/\\\\}" || grep -Em1 "^[[:blank:]]*$pattern" $file | sed 's|\\|\\\\|g')\e[0m"

			elif error=$( (( $(grep -Ec "^[[:blank:]]*$pattern" $file 2>&1) > 1 )) 2>&1); then
				[[ $error ]] && { syntax_error; return 1; }

				G_WHIP_MSG "[FAILED] Setting was found multiple times\n
The pattern \$1
	$(sed -E "c\\$pattern" <<< '')
was found multiple times in file \$3
	$file\n
____________
$(grep -En "^[[:blank:]]*$pattern" $file)
____________\n
Either the pattern \$1 needs to be more specific or the desired setting can appear multiple times by design and it cannot be predicted which instance to edit.
Please retry with more specific parameter \$1 or apply the setting manually:
	$setting_raw"

			else
				[[ $error ]] && { syntax_error; return 1; }

				[[ $GCI_BACKUP == 1 && ! -f $file.bak ]] && cp -a $file $file.bak && G_DIETPI-NOTIFY 2 "Config file backup created: \e[33m$file.bak\e[0m"
				error=$(sed -Ei "0,/^[[:blank:]]*$pattern.*$/s//$setting/" $file 2>&1) || { syntax_error; return 1; }
				G_DIETPI-NOTIFY 0 "Setting in \e[33m$file\e[0m adjusted: \e[33m${setting_raw//\\/\\\\}\e[0m"

			fi

		elif error=$(grep -Eq "^[[:blank:]#;]*$pattern" $file 2>&1); then
			[[ $error ]] && { syntax_error; return 1; }

			[[ $GCI_BACKUP == 1 && ! -f $file.bak ]] && cp -a $file $file.bak && G_DIETPI-NOTIFY 2 "Config file backup created: \e[33m$file.bak\e[0m"
			error=$(sed -Ei "0,/^[[:blank:]#;]*$pattern.*$/s//$setting/" $file 2>&1) || { syntax_error; return 1; }
			G_DIETPI-NOTIFY 0 "Comment in \e[33m$file\e[0m converted to setting: \e[33m${setting_raw//\\/\\\\}\e[0m"

		else
			[[ $error ]] && { syntax_error; return 1; }

			if [[ $after ]]; then

				if error=$(grep -Eq "^[[:blank:]]*$after" $file 2>&1); then

					[[ $GCI_BACKUP == 1 && ! -f $file.bak ]] && cp -a $file $file.bak && G_DIETPI-NOTIFY 2 "Config file backup created: \e[33m$file.bak\e[0m"
					error=$(sed -Ei "0,/^[[:blank:]]*$after.*$/s//&\n$setting/" $file 2>&1) || { syntax_error; return 1; }
					G_DIETPI-NOTIFY 0 "Added setting \e[33m${setting_raw//\\/\\\\}\e[0m to \e[33m$file\e[0m after line \e[33m$(grep -Em1 "^[[:blank:]]*$after" $file | sed 's|\\|\\\\|g')\e[0m"

				else
					[[ $error ]] && { syntax_error; return 1; }

					G_WHIP_MSG "[FAILED] Setting could not be added after desired line\n
The pattern \$4
	$(sed -E "c\\$after" <<< '')
could not be found in file \$3
	$file\n
Please retry with valid parameter \$4 or apply the setting manually:
	$setting_raw"

				fi

			else

				[[ $GCI_BACKUP == 1 && ! -f $file.bak ]] && cp -a $file $file.bak && G_DIETPI-NOTIFY 2 "Config file backup created: \e[33m$file.bak\e[0m"
				# The following sed does not work on empty files:
				[[ ! -s $file ]] && echo '# Added by DietPi:' >> $file
				error=$(sed -Ei "\$a\\$setting" $file 2>&1) || { syntax_error; return 1; }
				G_DIETPI-NOTIFY 0 "Added setting \e[33m${setting_raw//\\/\\\\}\e[0m to end of file \e[33m$file\e[0m"

			fi

		fi

	}

	#-----------------------------------------------------------------------------------
	[[ $G_DEBUG == 1 ]] && G_DIETPI-NOTIFY 2 'DietPi-Globals loaded'
	#-----------------------------------------------------------------------------------
	# Return exit code 0, by triggering null as last command to output
	:
	#-----------------------------------------------------------------------------------

}
